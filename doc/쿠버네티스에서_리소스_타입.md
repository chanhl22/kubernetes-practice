# 리소스 타입(Resource Type)?

**K8s API로 관리되는 객체(Object)의 종류**를 의미합니다.

즉, “쿠버네티스가 어떤 종류의 리소스를 관리할 수 있는가?”를 구분하는 단위입니다.

# 1. 리소스 타입(Resource Type) 기본 개념

K8s의 모든 리소스는 **YAML(manifest)** 파일로 정의되며, 이 파일의 **`kind` 필드**가 바로 리소스 타입을 나타냅니다.

```yaml
apiVersion: apps/v1
kind: Deployment  # ← 리소스 타입
metadata:
  name: my-app
spec:
  replicas: 3
  ...
```

여기서 `Deployment`가 리소스 타입입니다.

# 2. 리소스 타입의 주요 분류

K8s 리소스 타입은 크게 다음 네 가지로 나눌 수 있습니다.

| 분류 | 설명 | 예시 |
| --- | --- | --- |
| **Workload 리소스** | 실제로 컨테이너가 동작하는 애플리케이션 관련 리소스 | Pod, ReplicaSet, Deployment, StatefulSet, DaemonSet, Job, CronJob |
| **Service & Networking 리소스** | Pod 간 또는 외부와의 통신을 정의 | Service, Ingress, Endpoint, NetworkPolicy |
| **Configuration & Storage 리소스** | 환경변수나 설정파일, 볼륨을 관리 | ConfigMap, Secret, PersistentVolume(PV), PersistentVolumeClaim(PVC), StorageClass |
| **Cluster 관리 리소스** | 권한, 노드, 네임스페이스 등 클러스터 전반 관리 | Node, Namespace, Role, RoleBinding, ClusterRole, ClusterRoleBinding, ServiceAccount, CustomResourceDefinition(CRD) |

# 3. 대표적인 리소스 타입 정리

### 🧱 Workload

| 리소스 | 설명 |
| --- | --- |
| **Pod** | 가장 기본 단위. 1개 이상의 컨테이너 집합 |
| **ReplicaSet** | 동일한 Pod를 지정된 개수만큼 유지 |
| **Deployment** | ReplicaSet을 관리하며 롤링 업데이트, 롤백 지원 |
| **StatefulSet** | 상태를 가진 Pod 관리 (예: DB, Redis) |
| **DaemonSet** | 모든 Node에 1개씩 Pod 배포 |
| **Job / CronJob** | 일회성 혹은 주기적 작업 실행 |

### 🌐 Service & Networking

| 리소스 | 설명 |
| --- | --- |
| **Service** | Pod 집합에 접근하기 위한 네트워크 엔드포인트 |
| **Ingress** | 외부 트래픽을 클러스터 내부로 라우팅 |
| **NetworkPolicy** | Pod 간 통신 제어 (보안 정책) |

### ⚙️ Configuration & Storage

| 리소스 | 설명 |
| --- | --- |
| **ConfigMap** | 환경변수, 설정파일 등 일반 텍스트 저장 |
| **Secret** | 민감한 정보(비밀번호, 토큰 등) 저장 |
| **PersistentVolume (PV)** | 물리적 스토리지 리소스 정의 |
| **PersistentVolumeClaim (PVC)** | Pod가 요청하는 스토리지 리소스 |
| **StorageClass** | PV 동적 프로비저닝 정책 정의 |

### 🛡️ Cluster 관리 리소스

| 리소스 | 설명 |
| --- | --- |
| **Namespace** | 리소스를 논리적으로 구분 |
| **Node** | 실제 컨테이너가 동작하는 물리/가상 머신 |
| **Role / ClusterRole** | 권한 정의 (Namespace 단위 / 클러스터 전체) |
| **RoleBinding / ClusterRoleBinding** | 사용자에게 권한 연결 |
| **ServiceAccount** | Pod에서 K8s API 호출 시 인증용 계정 |
| [**CustomResourceDefinition (CRD)**](https://www.notion.so/28ac7ae958ac8087ae53fc883dc17865?pvs=21) | 사용자 정의 리소스 추가 (예: `kind: MyApp`) |

# 4. 리소스 타입 조회 명령어

쿠버네티스 CLI(kubectl)로 현재 지원되는 리소스 타입을 조회할 수 있습니다.

```bash
kubectl api-resources

# 출력 예시
NAME              SHORTNAMES   APIVERSION         NAMESPACED   KIND
pods              po           v1                 true         Pod
deployments       deploy       apps/v1            true         Deployment
services          svc          v1                 true         Service
configmaps        cm           v1                 true         ConfigMap
```

# [참고] Custom Resource (사용자 정의 리소스)

쿠버네티스는 확장성이 높아서, CRD (CustomResourceDefinition)를 이용해 **새로운 리소스 타입을 직접 정의**할 수 있습니다.

```yaml
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: myapps.mycompany.com
spec:
  group: mycompany.com
  versions:
    - name: v1
      served: true
      storage: true
  scope: Namespaced
  names:
    plural: myapps
    singular: myapp
    kind: MyApp
```

이제 `kind: MyApp`이라는 리소스 타입을 사용할 수 있게 됩니다.

# [참고] 리소스는 하나밖에 못쓰는거 아님?

결론부터 말하면 쿠버네티스 리소스는 하나만 쓸 수 있는 게 아닙니다.

오히려 **여러 리소스가 함께 정의되고 서로 연결**되어서 하나의 애플리케이션을 구성합니다.

## 1. “리소스는 하나만 쓴다”는 오해가 생기는 이유

쿠버네티스 YAML 파일에서 이렇게 보이죠.

```yaml
apiVersion: apps/v1
kind: Deployment  # 리소스 타입
metadata:
  name: my-app
```

여기서는 `kind: Deployment` 하나만 지정되어 있어서, “리소스는 하나만 쓸 수 있나?”라고 생각하기 쉽습니다.

하지만 사실상 이 YAML은 **하나의 리소스 객체**를 정의한 것뿐이에요.

하나의 리소스 타입만 포함되어 있을 뿐, **여러 개의 리소스를 묶어서 배포**하는 게 일반적입니다.

## 2. 여러 리소스를 동시에 정의하는 방법

쿠버네티스 매니페스트(YAML 파일) 안에는 여러 리소스를 `---` 구분선으로 나눠서 한 파일에 함께 정의할 수 있습니다.

```yaml
# ✅ 1. Deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
        - name: my-container
          image: nginx:latest
---
# ✅ 2. Service
apiVersion: v1
kind: Service
metadata:
  name: my-app-service
spec:
  selector:
    app: my-app
  ports:
    - port: 80
      targetPort: 80
---
# ✅ 3. ConfigMap
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-config
data:
  MESSAGE: "Hello from Kubernetes!"
```

이 파일은 한 번에 **3개의 리소스(Deployment, Service, ConfigMap)** 를 생성합니다.

그리고 명령어를 사용해 바로 설정을 적용할 수 있습니다.

```bash
kubectl apply -f app.yaml
```

## 3. 여러 리소스가 함께 동작하는 구조

이 리소스들은 각각 역할이 다르지만 **연결되어 하나의 시스템처럼 작동**합니다.

| 리소스 | 역할 |
| --- | --- |
| **Deployment** | Pod(컨테이너)을 여러 개 띄워서 애플리케이션 실행 |
| **Service** | 여러 Pod를 하나의 IP로 묶어서 네트워크 접근 제공 |
| **ConfigMap** | 애플리케이션 설정값 주입 (환경변수, 설정파일 등) |

즉, “하나의 리소스만 쓸 수 있다”가 아니라 **여러 리소스를 조합해서 하나의 완전한 애플리케이션을 구성**하는 것입니다.

쿠버네티스는 “조합형 아키텍처”라서 각 리소스가 역할을 나눠 수행하기 때문입니다.

## 4. 리소스 간 관계 예시 (시각적으로 보면)

```
┌──────────────┐
│  ConfigMap   │   ← 환경 설정 / 변수
└──────┬───────┘
       │
       ▼
┌──────────────┐
│  Deployment  │   ← 애플리케이션 실행 (Pod 관리)
└──────┬───────┘
       │
       ▼
┌──────────────┐
│     Pod      │   ← 실제 컨테이너 실행 단위
└──────┬───────┘
       │
       ▼
┌──────────────┐
│   Service    │   ← Pod 묶음에 대한 네트워크 엔드포인트
└──────┬───────┘
       │
       ▼
┌──────────────┐
│   Ingress    │   ← 외부 트래픽(사용자 요청) 진입점
└──────────────┘
```

### **① ConfigMap / Secret**

- **애플리케이션 설정값**을 저장합니다.

  예: DB 접속 URL, 환경 변수, 설정파일 내용 등

- **Deployment**가 Pod를 만들 때 이 값을 환경변수로 주입받습니다.
- 관계: ConfigMap → Deployment → Pod
- 예시

    ```yaml
    # 1️⃣ ConfigMap 정의
    apiVersion: v1
    kind: ConfigMap
    metadata:
      name: app-config
    data:
      DB_URL: "mysql://mydb:3306/app"
    ---
    # 2️⃣ Deployment 정의
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: configmap-demo
    spec:
      replicas: 1
      selector:
        matchLabels:
          app: configmap-demo
      template:
        metadata:
          labels:
            app: configmap-demo
        spec:
          containers:
            - name: demo-container
              image: busybox    # 단순 테스트용 이미지 (작고 빠름)
              command: ["sh", "-c", "echo $DB_URL && sleep 3600"]
    					**# ➡️ Deployment에서 참조**
              **env:
                - name: DB_URL
                  valueFrom:
                    configMapKeyRef:
                      name: app-config  # ConfigMap 이름
                      key: DB_URL       # ConfigMap 내부 key**
    ```


### ② **Deployment**

- **Pod를 생성하고 관리하는 상위 리소스**입니다.
- Pod가 죽으면 자동으로 다시 띄워주고, 버전 업데이트(롤링 업데이트)도 담당합니다.
- 내부적으로는 **ReplicaSet**을 생성해서 Pod 수를 유지합니다.
- 관계: Deployment → ReplicaSet → Pod
- 예시

    ```yaml
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: my-app
    spec:
      replicas: 3
      selector:
        matchLabels:
          app: my-app
      template:
        metadata:
          labels:
            app: my-app
        spec:
          containers:
            - name: nginx
              image: nginx:latest
    ```


### ③ **Pod**

- 쿠버네티스에서 **실제로 컨테이너가 실행되는 최소 단위**입니다.
- Pod는 하나 또는 여러 개의 컨테이너를 포함할 수 있습니다.
- Pod는 수명이 짧기 때문에 직접 접근하기보단 `Service`를 통해 접근합니다.
- 관계:
    - Pod ← Deployment (관리)
    - Pod → Service (트래픽 연결)

### ④ **Service**

- 여러 개의 Pod를 **하나의 네트워크 엔드포인트로 묶어주는 역할**을 합니다.
- Pod는 IP가 동적으로 바뀌기 때문에, 고정된 접근점을 제공해줍니다.
- 내부에서 `selector`를 사용해 어떤 Pod를 묶을지 결정합니다.
- 관계: Service → Pod (selector로 연결)
- 예시

    ```yaml
    apiVersion: v1
    kind: Service
    metadata:
      name: my-app-service
    spec:
      selector:
        app: my-app
      ports:
        - port: 80
          targetPort: 80
    ```


### ⑤ **Ingress**

- 클러스터 **외부에서 들어오는 HTTP/HTTPS 요청의 진입점**입니다.
- 여러 개의 Service로 트래픽을 라우팅할 수 있습니다.
- 일반적으로 `Ingress Controller` (예: Nginx Ingress Controller)가 필요합니다.
- 관계: Ingress → Service → Pod
- 예시

    ```yaml
    apiVersion: networking.k8s.io/v1
    kind: Ingress
    metadata:
      name: my-ingress
    spec:
      rules:
        - host: myapp.example.com
          http:
            paths:
              - path: /
                pathType: Prefix
                backend:
                  service:
                    name: my-app-service
                    port:
                      number: 80
    ```


### 트래픽 / 데이터 흐름 정리

| 단계 | 흐름 | 설명 |
| --- | --- | --- |
| 1 | **사용자 → Ingress** | 외부 요청이 Ingress Controller로 들어옴 |
| 2 | **Ingress → Service** | 도메인/경로 규칙에 따라 적절한 Service로 전달 |
| 3 | **Service → Pod** | selector에 맞는 Pod로 트래픽 전달 |
| 4 | **Pod 내부에서 실행** | 컨테이너가 요청을 처리 |
| 5 | **Pod → ConfigMap/Secret** | 설정값이나 인증정보를 참조하여 동작 |

## 5. 정리

| 질문 | 답변 |
| --- | --- |
| 리소스는 하나만 쓸 수 있나요? | ❌ 아니요, 여러 리소스를 함께 정의할 수 있습니다. |
| 어떻게 여러 리소스를 정의하나요? | YAML 파일에 `---`로 구분하거나 여러 파일로 작성 후 `kubectl apply -f .` |
| 왜 여러 개를 써야 하나요? | 쿠버네티스는 “조합형 아키텍처”라서 각 리소스가 역할을 나눠 수행하기 때문입니다. |